 /** 
 *  @file
 *  @defgroup Jelmers FLEX decoder first stage <flex.c>
 *  @code #include <flex.c> @endcode
 * 
 *  @brief First stage flex decoder handles all the raw stuff. It uses a fixed 1600 baud reading speed, generated by TIMER 1.
 *	Timing and clockrecovery is performed by slaving the timer to rising and falling edges; if the edge falls within a certain
 *	bracket, timing is adjusted.
 *	All the important stuff such as a state machine is handled in the COMPA vector, triggered every bit.

 *
 *  @note Based on US patent US55555183
 *  @author Jelmer Bruijn
 */
 

#include <avr/io.h>
#include <avr/interrupt.h>



#define F_CPU 16000000UL
#define UART_BAUD_RATE      115200UL 
#include "uart.h"

#include <util/atomic.h>
#include <stdlib.h>

#include "flex.h"
#include "flexprocess.h"

//#define SERDEBUG

struct rx current;

#ifdef SERDEBUG
	char buffer[10];
#endif

uint32_t currentword32 = 0;
uint16_t currentword16 = 0;
uint8_t currentbyte = 0;
uint8_t synced = 0;
uint8_t badsyncs = 0;
volatile uint8_t state = 0;

char bitswitch(char b){
	// a really cool way to reverse bit order. Not sure if it's the fastest, but it works!
	b = (b * 0x0202020202ULL & 0x010884422010ULL) % 1023;
	return (b);
}

/* this function will validate a single word in a frame, and/or repair single or double bit errors
	task = VALIDATE_FLEC_CHECKSUM|REPAIR1|REPAIR2
	returns: VALIDATE_FAIL, VALIDATE_PASS, REPAIRED_1 (1 bit repaired) , REPAIRED_2 (2 bits repaired)
*/
uint8_t validateWord(struct frame* frame, uint8_t word, uint8_t task){
	uint32_t wordvalue;
	wordvalue = *getWord(frame, word);
	if(validateBCH(wordvalue)){
		if(task&VALIDATE_FLEX_CHECKSUM){
			if(validateChecksum(wordvalue)){
				return VALIDATE_PASS;
			} else {
				return VALIDATE_FAIL;
			}
		} else {
			return VALIDATE_PASS;
		}
	} else {
		uint8_t counter;
		if(task&REPAIR1){
			for(counter=0;counter<31;counter++){
				if(validateBCH(wordvalue^(1<<counter))){
					wordvalue = (word^(1<<counter));
					*getWord(frame,word) = wordvalue;
					if(task&VALIDATE_FLEX_CHECKSUM){
						if(validateChecksum(wordvalue)){
							return REPAIRED_1;
						} else {
							return VALIDATE_FAIL;
						}
					} else {
						return REPAIRED_1;
					}
				}
			}
			if(!(task&REPAIR2)) return VALIDATE_FAIL;
		}
		
		if(task&REPAIR2){
			uint8_t counter2;
			for(counter2=0;counter2<31;counter2++){
				for(counter=counter2+1;counter<31;counter++){
					if(validateBCH(  (wordvalue^(1<<counter))^(1<<counter2) ) ){
						wordvalue = (wordvalue^(1<<counter))^(1<<counter2);
						*getWord(frame,word) = wordvalue;
						if(task&VALIDATE_FLEX_CHECKSUM){
							if(validateChecksum(wordvalue)){
								return REPAIRED_2;
							} else {
								return VALIDATE_FAIL;
							}
						} else {
							return REPAIRED_2;
						}
					}
				}
			}
		} else {
			return VALIDATE_FAIL;
		}
	}
	return VALIDATE_FAIL;
}

// returns the pointer to a single 32-bit word from a frame
uint32_t* getWord(struct frame* frame, uint8_t word){
	return &(frame->block[word/8]->word[word%8]);	
}

// deletes a frame and the blocks in it
void cleanUpFrame(struct frame* frame){
	uint8_t blockcount = 0;
	ATOMIC_BLOCK(ATOMIC_RESTORESTATE){
		if(frame){
			for(blockcount=0;blockcount<11;blockcount++){
				if(frame->block[blockcount]){
					free(frame->block[blockcount]);
				}
			}
			free(frame);
		}
	}
}

// verifies if the block in a frame contains the idle signature
uint8_t checkIdle(struct frame* frame, uint8_t block){
	// check 3 consecutive words, if they have an idle signature, the rest of the block is too
	if(frame->block[block]->word[0]==0x00000000){
		if(frame->block[block]->word[1]==0xffffffff){
			if(frame->block[block]->word[2]==0x00000000){
				// if idle, free the block
				ATOMIC_BLOCK(ATOMIC_FORCEON){
					free(frame->block[block]);
				}
				// block freed, unset pointer to block to ensure it will not be freed twice
				frame->block[block]=0;
				return 1;
			}
		}
	}
	return 0;
}

// decodes the frame information word
void processFIW(uint32_t fiwword, struct frame* frame){
	fiwword>>=11;
	frame->fiw.traffic = fiwword&0x0F;
	frame->fiw.repeat = fiwword&0x10;
	fiwword>>=5;
	frame->fiw.frame = bitswitch((uint8_t)fiwword);
	fiwword>>=4;
	frame->fiw.cycle = bitswitch(((uint8_t)fiwword)&0xF0);
}

// calculates a CRC for a 32 bit word
uint32_t createCRC(uint32_t in) {
	// I borrowed this routine from Kristoff. Credit goes to him!
	// https://github.com/on1arf/rf22_pocsag
	// (c) 2014 Kristoff Bonne (ON1ARF)
	// 
	// local vars
	uint32_t cw; // codeword
	uint32_t local_cw = 0;
	uint32_t parity = 0;
	// init cw
	cw=in;
	// move up 11 bits to make place for crc + parity
	local_cw=in; /* bch */
	// calculate crc
	for (int bit=1; bit<=21; bit++, cw <<= 1) {
		if (cw & 0x80000000) {
			cw ^= 0xED200000;
		}; // end if
	}; // end for
	local_cw |= (cw >> 21);
	// parity
	cw=local_cw;
	for (int bit=1; bit<=32; bit++, cw<<=1) {
		if (cw & 0x80000000) {
			parity++;
		}; // end if
	}; // end for
	// make even parity
	if (parity % 2) {
		local_cw++;
	}; // end if
	// done
	return(local_cw);
}

uint8_t validateBCH(uint32_t in){
	uint32_t testword;
	// select only the first 21 bits of the 32 bit word
	testword = in&0b11111111111111111111100000000000;
	testword = createCRC(testword);
	
	// check if the word is equal now that we've regenerated the parity and CRC
	if(testword==in){
		return 1;
	} else {
		return 0;
	}
}

// validates the motorola checksum (a 4 bit checksum) for specific codewords such as block info and frame info
uint8_t validateChecksum(uint32_t word){
	uint8_t checksum;
	uint8_t totalizer = 0;
	checksum=((uint8_t)(word>>28))&0x0F;
	word>>=4;
	totalizer = bitswitch((uint8_t)word)&0x01;
	word>>=4;
	totalizer+= bitswitch((uint8_t)word)&0x0F;
	word>>=4;
	totalizer+= bitswitch((uint8_t)word)&0x0F;
	word>>=4;
	totalizer+= bitswitch((uint8_t)word)&0x0F;
	word>>=4;
	totalizer+= bitswitch((uint8_t)word)&0x0F;
	totalizer&=0x0F;
	totalizer = bitswitch(totalizer);
	totalizer^=0xFF;
	totalizer>>=4;
	if(totalizer==checksum){
		return 1;
	} else {
		return 0;
	}
}

// attempts to recover a single bit error in a word
uint32_t recoverError(uint32_t word){
	uint8_t counter;
	for(counter=0;counter<31;counter++){
		if(validateBCH(word^(1<<counter))){
			return (word^(1<<counter));
		}
	}
	return word;
}


// validates entire block, and marks invalid words in the block check byte
void validateBlock(struct block* block){
	uint8_t counter;
	for(counter=0;counter<8;counter++){
		// check if the word in the block validates
		if(validateBCH(block->word[counter])){
			// if valid, mark as valid in the word-check field
			block->check|=(1<<counter);
		} else {
			// if invalid, attempt to recover
			block->word[counter]=recoverError(block->word[counter]);
			if(validateBCH(block->word[counter])){
				block->check|=(1<<counter);
				#ifdef SERDEBUG
					uart_puts_P("ERROR IN WORD ");itoa(counter, buffer, 10);uart_puts(buffer);
					uart_puts_P(" RECOVERED!\n\r");
				#endif
			} else {
				#ifdef SERDEBUG
					uart_puts_P("ERROR IN WORD");itoa(counter, buffer, 10);uart_puts(buffer);
					uart_puts_P("\n\r");
				#endif
			}
		}
	}
}

// initializes the network layer
void startFlex(void){
	// initialises the decoder
	current.bitcounter=0;
	current.block = 0;
	current.lastblock = 0;
	current.lastframe = 0;
	current.frame = 0;
	
	synced = 0;
	state = 0;
	
	uart_init( UART_BAUD_SELECT(UART_BAUD_RATE,F_CPU) ); 
	
	// initial state is to wait for a sync
	state = WAIT_SYNC;
	
	// sync-counter set to 0, this has to rise to MIN_SYNC
	synced = 0;
	
	// init timer, enable all three interrupts
	TIMSK1|=(1<<ICIE1)|(1<<OCIE1A)|(1<<OCIE1B);
	
	// set OCR1A to normal period + stddev, within the window of STDBIT-STDDEV and STDBIT+STDDEV a rising or falling edge will slave the timer to this sync phase
	OCR1A = STDBIT+STDDEV;
	
	// set OCR1B to exactly half the period, to sample the bitvalue exactly in the middle
	OCR1B = STDBIT>>1;
	
	
	// enable timer, no prescalar, interrupt on rising edge (the last one isn't really relevant, as it's toggled within the interrupt)
	TCCR1B|=(1<<CS10)|(1<<ICNC1);
	//TCCR1B|=(1<<WGM12);//|(1<<WGM13);
	
	
	DDRC=0x3E; // for status leds, optional
	PORTC|=(1<<POWERLED);

	// extra pull-up on ICP1, for those nice sharp edges
	PORTB|=(1<<PORTB0);
	
	// enable ADC with internal reference, prescaler 128
	ADMUX|=(1<<REFS0)|(1<<REFS1);
	ADCSRA|=(1<<ADEN)|(1<<ADIE)|(1<<ADSC)|(1<<ADATE)|(1<<ADPS0)|(1<<ADPS1)|(1<<ADPS2);
	
	sei();
	
	// initialize the transport layer (and probably some other layers too)
	initProcessor();
}

// Switches on the pretty lights
void Lights(){
	// some LED stuff. Not critical, can be set to anything
	if(synced>MINSYNC){
		PORTC|=(1<<SYNCLED);
	} else {
		PORTC&=~(1<<SYNCLED);
	}
	
	if(state==BLOCK){
		PORTC|=(1<<BLOCKLED);
	} else {
		PORTC&=~(1<<BLOCKLED);
	}
	
	if((state==IDLE)||(state==IDLE_PROC_STARTED)){
		PORTC|=(1<<IDLELED);
	} else {
		PORTC&=~(1<<IDLELED);
	}
	
	if((badsyncs)&&(state>SYNCED)){
		PORTC|=(1<<ERRORLED);
	} else {
		PORTC&=~(1<<ERRORLED);
	}
}


// this interrupt is called every rising or falling edge of the FSK signal
ISR(TIMER1_CAPT_vect){
	// save the capture value;
	uint16_t capture = ICR1;
	
	// switch interrupt edge
	if(TCCR1B&(1<<ICES1)){
		TCCR1B&=~(1<<ICES1);
	} else {
		TCCR1B|=(1<<ICES1);
	}
	
	// if synced = 0; treat as the first reference pulse and start the reference timing
	if(synced==0){
		synced=1;
		TCNT1=0;
		OCR1B=STDBIT>>1;
	}
	
	// check if the input capture falls within the validity period.
	if(capture>=STDBIT){
		
		// if we're not at the maximum sync, up the counter
		if(synced<MAXSYNC)synced++;
		
		// the received edge is late, but within the window. Sync timer to this edge
		TCNT1=0;
	} else if(capture>(STDBIT-STDDEV)){
		// if we're not at the maximum sync, up the counter
		if(synced<MAXSYNC)synced++;
		
		// received edge is early but within window. Sync to this edge
		TCNT1=0;
	} else {
		// apparently, a sync pulse was received outside of the intended window. Either regular noise or a small glitch.
		
		// if we were previously synced, decrease the counter
		if(synced>0){
			synced--;
			
			// if we were receiving data, count it as a bad sync (ERROR led will also be lit)
			if(state>WAIT_SYNC){
				badsyncs++;
			}
		}
		
		// if we're already in the frame phase, we'll have to do some other stuff
		if((state>WAIT_SYNC)&&(synced==0)){
			// if further than synced, a frame has been allocated. We're gonna have to remove that frame
			if(state>SYNCED){
				switch(state){
					case BLOCK:
					case IDLE:
						state=WAIT_SYNC;
						synced=0;
						current.lastframe=current.frame;
						sei();
						processFrame(current.lastframe);
						break;
					case IDLE_PROC_STARTED:
						state=WAIT_SYNC;
						synced=0;
						current.lastframe=current.frame;
						sei();
						break;
					default:
						state=WAIT_SYNC;
						synced=0;
						current.lastframe=current.frame;
						cleanUpFrame(current.lastframe);
						sei();
						break;
				}
				#ifdef SERDEBUG
					uart_puts_P("-- Partial frame ");itoa((int)current.frame->fiw.frame, buffer, 10);uart_puts(buffer);uart_puts_P(", terribly sorry.\r\n");
				#endif
			} else {
				state=WAIT_SYNC;
			}
		}
		
	}
	
	// if the previous state was waiting for sync and enough edges were detected, switch to 'SYNCED' state
	if((state==WAIT_SYNC)&&(synced>=MINSYNC)){
		state=SYNCED;
	}
}

// this interrupt is triggered if there was no edge within the expected period. This happens when there's 2 or more consecutive 1's or 0's
// reset the timer counter to the stddev, as this interrupt gets triggered after the normal period + stddev
ISR(TIMER1_COMPA_vect){
	TCNT1=STDDEV;
}

// this interrupt is called to read a bit, right in the middle of the regular bit period/field
ISR(TIMER1_COMPB_vect){

	uint8_t counter;
	uint8_t bit = !(PINB&1);
	
	/*
	*	The state machine as described here will switch through the different blocks, as described in US patent
	*	5555183. Not everything is verified, but most is. The state machine will only recognize the 'A' 32-bit
	*	word for 1600 bps (2-level FSK)
	*		BS1		    A1		  B		   ~A1		FIW		  BS2		C		 ~BS2      ~C	  First block
	*	 +---------+---------+---------+---------+---------+--------+---------+--------+---------++---------+
	*	 | 32 bits | 32 bits | 16 bits | 32 bits | 32 bits | 4 bits | 16 bits | 4 bits | 16 bits || BLOCK 0 |
	*	 +---------+---------+---------+---------+---------+--------+---------+--------+---------++---------+
	*			SYNCED		    SYNC_B SYNC_NOT_A1  FIW		SYNC_BS2  SYNC_C  SYNC_NOT_BS2 SYNC_NOT_C
	*/
	switch(state){
		case SYNCED: // trained onto first bitsync, look for 'A' pattern
			currentword32>>=1; // shift to the right, as LSB is sent first
			if(bit)currentword32|=0x80000000;
			if(currentword32==0x9c9acf1e){
				state = SYNC_B;
				currentword16 = 0;
				current.bitcounter = 0;
				badsyncs=0;
				//NON-REENTRANT!
				current.frame=calloc(1,sizeof(struct frame));
				if(current.frame==NULL){
					// calloc failed :(
					state = WAIT_SYNC;
					synced = 0;
				} else {
					// calloc succeeded
					for(counter=0;counter<11;counter++){
							current.frame->block[counter]=0;
					}
				}
			}
			break;
		case SYNC_B:
			currentword16>>=1;
			if(bit)currentword16|=0x8000;
			current.bitcounter++;
			if((current.bitcounter==16)&&(currentword16==0xAAAA)){
				state = SYNC_NOT_A1;
				currentword32=0x00000000;
				current.bitcounter=0;
			} else if(current.bitcounter==16){
				state=WAIT_SYNC;
				cleanUpFrame(current.frame);
			}
			break;
		case SYNC_NOT_A1:
			currentword32>>=1;
			if(bit)currentword32|=0x80000000;
			current.bitcounter++;
			if((current.bitcounter==32)){
				if(currentword32==~(0x9c9acf1e)){
					state = FRAME_INFO;
					current.bitcounter = 0;
					currentword32 = 0;
				} else {
					state=WAIT_SYNC;
					cleanUpFrame(current.frame);
				}
			}
			break;
		case FRAME_INFO:
			currentword32<<=1;
			if(bit){
				currentword32|=0x01;
			}
			current.bitcounter++;
			if(current.bitcounter==32){
				if(validateBCH(currentword32)){
					state = SYNC_BS2;
					current.bitcounter = 0;
					currentbyte = 0;
					sei();
					if(!validateChecksum(currentword32)){
						#ifdef SERDEBUG
							uart_puts_P("-- Error in FIW, aborting frame\n\r");
						#endif
						state=WAIT_SYNC;
						cleanUpFrame(current.frame);
					} else {
						processFIW(currentword32,current.frame);
					}
				} else {
					state=WAIT_SYNC;
					cleanUpFrame(current.frame);
					
				}
			}
			break;
		case SYNC_BS2:
			currentbyte>>=1;
			if(bit)currentbyte|=0x80;
			current.bitcounter++;
			if((current.bitcounter==4)&&(currentbyte==0x50)){
				state=SYNC_C;
				currentword16=0;
				current.bitcounter=0;
			} else if(current.bitcounter==4){
				state=WAIT_SYNC;
				cleanUpFrame(current.frame);
			}
			break;
		case SYNC_C:
			currentword16>>=1;
			if(bit)currentword16|=0x8000;
			current.bitcounter++;
			if(current.bitcounter==16){
				state=SYNC_NOT_BS2;
				current.bitcounter = 0;
				currentbyte = 0;
			}
			break;
		case SYNC_NOT_BS2:
			currentbyte>>=1;
			if(bit)currentbyte|=0x80;
			current.bitcounter++;
			if((current.bitcounter==4)&&(currentbyte==0xa0)){
				state=SYNC_NOT_C;
				currentword16=0;
				current.bitcounter=0;
			} else if(current.bitcounter==4){
				state=WAIT_SYNC;
				cleanUpFrame(current.frame);
			}
			break;
		case SYNC_NOT_C:
			currentword16>>=1;
			if(bit)currentword16|=0x8000;
			current.bitcounter++;
			if((current.bitcounter==16)&&(currentword16==0xDE48)){
				state=BLOCK;
				current.bitcounter = 0;
				current.block = 0;
				currentword32 = 0;
			} else if(current.bitcounter==16){
				state=WAIT_SYNC;
				cleanUpFrame(current.frame);
			}
			break;			
		case BLOCK:
			// block stage - the storing of bits happens here. The administration / counter-updating happens below
			
			//start of a new block
			if(current.bitcounter==0){				
				//NON-REENTRANT!
				struct block *block = calloc(1,sizeof(struct block));
				#ifdef SERDEBUG
				if(block==NULL){
					uart_puts_P("CALLOC FOR BLOCK FAILED :(\n\r");
				}
				#endif
				current.frame->block[current.block] = block;
				block->check=0;
			}
			
			// check if the block was assigned properly
			if(current.frame->block[current.block]){
				// The flex interleave bit storage thingy (bits are stored here)
				current.frame->block[current.block]->word[current.bitcounter%8]<<=1;
				if(bit)current.frame->block[current.block]->word[current.bitcounter%8]|=0x01;
			}
			
			// fallthrough
		case IDLE:
		case IDLE_PROC_STARTED:
			// administration an counting of bits and blocks happens here. If the last block is idle, no bits are stored, but
			// we're still counting bits to make sure the end of the frame is properly detected
			current.bitcounter++;
			//check if end of block, 8 words received (256 bits)
			if(current.bitcounter==0){
					current.lastblock = current.block;
					current.lastframe = current.frame;
					current.block++;
					
					// this removes any idle codeblocks after receiving, to save space, and start early processing if not busy with previous frame
					switch(state){
						case BLOCK:
							if(checkIdle(current.lastframe,current.lastblock)){ 
								// last block was idle
								state=IDLE;
								// fallthrough to case IDLE
							} else {
								// block was not idle
								if(current.lastblock==10){
									// last block
									state=SYNCED;
									sei();
									validateBlock(current.lastframe->block[current.lastblock]);
									processFrame(current.lastframe);
									break;
								} else {
									// not the last block
									sei();
									validateBlock(current.lastframe->block[current.lastblock]);
									break;
								}
							}
							// fallthrough
						case IDLE:
							if(current.lastblock==10){
								state=SYNCED;
								sei();
								processFrame(current.lastframe);
								break;
							}
							
							if(procmutex==0){
								state=IDLE_PROC_STARTED;
								sei();
								processFrame(current.lastframe);
								break;
							}

						case IDLE_PROC_STARTED:
							state=SYNCED;
							sei();
							break;
					}				
			}
			break;
	}
	Lights();
}

// called whenever the ADC is done doing its conversion, for reading RSSI values.
ISR(ADC_vect){
	rssi.adcdiv++;
	if(rssi.adcdiv==0){
		if(synced==0){
			rssi.noise[rssi.adccount]=(uint8_t)(ADC>>2);
		} else if(state>=BLOCK){
			rssi.block[rssi.adccount]=(uint8_t)(ADC>>2);
		}
		rssi.adccount++;
		if(rssi.adccount==ADCSAMPLES){
			rssi.adccount=0;
			sei();
			uint16_t temp=0;
			uint8_t count;
			for(count=0;count<ADCSAMPLES;count++){
				temp+=rssi.block[count];
			}
			temp>>=3;
			rssi.avgblock = temp;
			for(count=0;count<ADCSAMPLES;count++){
				temp+=rssi.noise[count];
			}
			temp>>=3;
			rssi.avgnoise = temp;
		}
		
	}
}