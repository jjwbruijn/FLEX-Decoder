/** 
 *  @file
 *  @defgroup Jelmers FLEX decoder first stage <flex.h>
 *  @code #include <flex.h> @endcode
 * 
 *  @brief First stage flex decoder handles all the raw stuff. It uses a fixed 1600 baud reading speed, generated by TIMER 1.
 *	Timing and clockrecovery is performed by slaving the timer to rising and falling edges; if the edge falls within a certain
 *	bracket, timing is adjusted.
 *	All the important stuff such as a state machine is handled in the COMPA vector, triggered every bit.

 *
 *  @note Based on US patent US55555183
 *  @author Jelmer Bruijn
 */

#ifndef FLEX_H_
#define FLEX_H_

// sync locking
#define STDDEV 3000		// std deviation of 30% stddev
#define STDBIT 10000	// 1600 baud @ 16Mhz
#define MAXSYNC 200
#define MINSYNC 8		// minimum training length

// state-machine states
#define WAIT_SYNC 0
#define SYNCED 1
#define SYNC_B 3
#define SYNC_NOT_A1 4
#define FRAME_INFO 5
#define SYNC_BS2 6
#define SYNC_C 7
#define SYNC_NOT_BS2 8
#define SYNC_NOT_C 9
#define BLOCK 10
#define IDLE 11
#define IDLE_PROC_STARTED 12

// leds
#define SYNCLED 1
#define BLOCKLED 2
#define POWERLED 3
#define ERRORLED 4
#define IDLELED 5

// validation tasks (if nothing is specified, only BCH will be verified)
#define VALIDATE_FLEX_CHECKSUM 1
#define REPAIR1 2
#define REPAIR2 6

// validation return
#define VALIDATE_FAIL 0
#define VALIDATE_PASS 1
#define REPAIRED_1	3
#define REPAIRED_2	5

struct system{
	uint8_t subsecond;
	uint16_t year;
	uint8_t month;
	uint8_t day;
	uint8_t hour;
	uint8_t minutes;
	uint8_t seconds;
	uint16_t localid;
	uint8_t timezone;
	uint8_t spare;
	uint8_t frameoffset;
} sys;

struct block{
	uint32_t word[8];
	uint8_t check;
}; // 33

struct frame{
	struct block* block[11];
	struct fiw{
		//uint8_t x;
		uint8_t cycle;
		uint8_t frame;
		uint8_t repeat;
		uint8_t traffic;
	} fiw;
	struct biw{
		//uint8_t x;
		uint8_t priority;
		uint8_t endofblockinfo;
		uint8_t addressstart;
		uint8_t vectorstart;
		uint8_t carryon;
		uint8_t collapse;
	} biw;
}; // 32

struct rx{
	uint8_t bitcounter;
	uint8_t block;
	uint8_t lastblock;
	struct frame* lastframe;
	struct frame* frame;
};

#define ADCSAMPLES 8
struct level{
	uint8_t block[ADCSAMPLES];
	uint8_t noise[ADCSAMPLES];
	uint8_t avgblock;
	uint8_t avgnoise;
	uint8_t adccount;
	uint8_t adcdiv;
} rssi;

/** @brief  Switches bits within byte MSB to LSB and v.v.
 *  @param  b the byte that will be switched
 *	@return Switched byte      
 */
char bitswitch(char b);

/** @brief  Fetches a specific word from the frame
 *  @param	frame the frame that contains the word to be validated
 *	@param	word the word to validate/repair
 *	@param	task The task that needs to be performed (see #defines)
 */
uint8_t validateWord(struct frame* frame, uint8_t word, uint8_t task);


/** @brief  Fetches a specific word from the frame
 *  @param  the frame used to fetch the word
 *	@param	the word to retrieve
 */ 
uint32_t* getWord(struct frame* frame, uint8_t word);

/** @brief  Recursively cleans up the frame (free's underlying blocks)
 *  @param  the frame that needs to be cleaned up
 */
void cleanUpFrame(struct frame* frame);


/** @brief  Check if selected block is idle, and free() if this is the case
 *  @param  frame Pointer to the frame that will be checked
 *	@param	block that shall be checked
 *	@return 1 if block contained idle words, and was deleted
 */
uint8_t checkIdle(struct frame* frame, uint8_t block);

/** @brief  Processes the Frame Information Word, storing the data in the fiw struct of the frame
 *  @param  fiwword Received dataword
 *	@param	frame Frame that should be used to store the FIW data after decoding
 */
void processFIW(uint32_t fiwword, struct frame* frame);

/** @brief  Creates CRC (BCH) and Parity for data
 *  @param	in Data to be CRC'd
 *	@return Dataword with CRC bits and parity added
 */
uint32_t createCRC(uint32_t in);


/** @brief  Wrapper for checking if the BCH data for a dataword is valid.
 *  @param	in Data to be verified
 *	@return 1 if valid
 */
uint8_t validateBCH(uint32_t in);

/** @brief  Validates the Motorola/FLEX 4 bit verification nibble
 *  @param	in Data to be verified
 *	@return 1 if valid
 */
uint8_t validateChecksum(uint32_t word);

/** @brief  Recovers a single bit error in a 32 bits word
 *  @param	in Data to be recovered
 *	@return Recovered word
 */
uint32_t recoverError(uint32_t word);

/** @brief  Recursively attempts to validate an entire block. Saves data in block->check
 *  @param	block Datablock to be verified
 */
void validateBlock(struct block* block);

/** @brief Sets up registers, timers, ports  */
void startFlex(void);

/** @brief Process all the different states and updates the panel-leds */
void Lights();



#endif /* FLEX_H_ */
